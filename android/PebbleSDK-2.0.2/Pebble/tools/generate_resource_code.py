#!/usr/bin/env python

import argparse
import os
import struct

import stm32_crc

def cmd_resource_header(args):
    if (len(args.resource_pair_list) % 2) != 0:
        raise Exception("resource_pair_list list must have an even number of entries")
    with open(args.output_header, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

#include <stdint.h>
#include "{resource_header}"
typedef enum {{
  INVALID_RESOURCE = 0,
  DEFAULT_MENU_ICON = 0, // Friendly synonym for use in `PBL_APP_INFO()` calls
""".format(resource_header=args.resource_include))
        for i in range(1, len(args.resource_pair_list), 2):
            output_file.write("  RESOURCE_ID_" + args.resource_pair_list[i] + ",\n")

        output_file.write("""
} ResourceId;
""")

        if args.version_def_name:
            with open(args.data_file, 'rb') as f:
                crc = stm32_crc.crc32(f.read())

            output_file.write("""
static const ResBankVersion {} = {{
  .crc = {},
  .timestamp = {}
}};
""".format(args.version_def_name, crc, args.timestamp))

        output_file.write("""
static const uint32_t resource_crc_table[] = {
""")

        for i in range(0, len(args.resource_pair_list), 2):
            with open(args.resource_pair_list[i], 'rb') as f:
                output_file.write("  " + str(stm32_crc.crc32(f.read())) + ",\n")
        output_file.write('};\n\n')



def cmd_font_key_header(args):
    with open(args.output_header, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

""")
        for key in args.resource_key_list:
            output_file.write("#define FONT_KEY_{key} \"RESOURCE_ID_{key}\"\n".format(key=key))



def cmd_font_key_table(args):
    with open(args.output_code_file, 'w') as output_file:
        output_file.write("""
//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

""")

        output_file.write('#include "%s"\n' % args.resource_id_header)
        output_file.write('#include "%s"\n' % args.font_key_header)

        output_file.write("""
static const struct {
  const char *key_name;
  ResourceId resource_id;
} s_font_resource_keys[] = {
""")

        for key in args.font_key_list:
            output_file.write("  {{ FONT_KEY_{key}, RESOURCE_ID_{key} }},\n".format(key=key))

        output_file.write("};\n")


def main():
    parser = argparse.ArgumentParser(description="Generate the needed code to use resources")
    subparsers = parser.add_subparsers(help="commands", dest='which')

    resource_header_parser = subparsers.add_parser('resource_header', help="make the resource id/crc/version file")
    resource_header_parser.add_argument('--version_def_name', metavar="VERSION_DEF_NAME", help="Name of the resource version")
    resource_header_parser.add_argument('output_header', metavar="OUTPUT_HEADER", help="File to write to")
    resource_header_parser.add_argument('timestamp', metavar="TIMESTAMP", help="Timestamp associated with this pack", type=int)
    resource_header_parser.add_argument('resource_include', metavar="RESOURCE_INCLUDE", help="Include path to insert into the output file")
    resource_header_parser.add_argument('data_file', metavar="DATA_FILE", help="The data chunk file")
    resource_header_parser.add_argument('resource_pair_list', metavar="RESOURCE_PAIR_LIST", help="list of pairs of <filename> <defname>", nargs="*")
    resource_header_parser.set_defaults(func=cmd_resource_header)

    font_key_header_parser = subparsers.add_parser('font_key_header', help="Make the font key header file")
    font_key_header_parser.add_argument('output_header', metavar="OUTPUT_HEADER", help="file to write to")
    font_key_header_parser.add_argument('resource_key_list', metavar="RESOURCE_KEY_LIST", help="List of resource IDs of fonts", nargs="*")
    font_key_header_parser.set_defaults(func=cmd_font_key_header)

    font_table_header_parser = subparsers.add_parser('font_key_table', help="Make the font key header file")
    font_table_header_parser.add_argument('output_code_file', metavar="OUTPUT_CODE_FILE", help="C file to write to")
    font_table_header_parser.add_argument('resource_id_header', metavar="resource_id_header", help="header to include to get the resource id's")
    font_table_header_parser.add_argument('font_key_header', metavar="font_key_header", help="header to include to get the font keys")
    font_table_header_parser.add_argument('font_key_list', metavar="FONT_KEY_LIST", help="List of resource def_names of fonts", nargs="*")
    font_table_header_parser.set_defaults(func=cmd_font_key_table)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
